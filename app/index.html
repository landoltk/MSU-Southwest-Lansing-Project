<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
        href="https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.css"
        rel="stylesheet"
    />
    
    <style>
        html, body { height: 100%; margin: 0; }
        #map { height: 100%; width: 100%; }

        .panel {
        position: absolute; z-index: 2; top: 100px; left: 12px;
        background: #fff; padding: 10px 12px; border-radius: 8px;
        box-shadow: 0 1px 4px rgba(0,0,0,0.15);
        font: 13px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        max-width: 360px;
        }
        .panel code { background: #f1f5f9; padding: 0 4px; border-radius: 4px; }
        .btn {
        display: inline-block; padding: 6px 10px; border-radius: 6px;
        background: #2563eb; color: #fff; border: none; cursor: pointer;
        font: inherit;
        }
        .btn:disabled { background: #9ca3af; cursor: not-allowed; }
        .muted { color: #475569; }
    </style>

    <title>SWLP Prototype Map</title>
    <link rel="stylesheet" href="static/style.css" />
</head>
<body>
    <h1>SWLP Prototype</h1>
    <div id="map"></div>

    <!--Need to add block selection to panel-->
    <div class="panel"> 
        <button id="reload" class="btn">Reload list</button>
        <div id="status" class="muted" style="margin-top:8px;"></div>
    </div>

    <!--MapLibre Section-->
    <script src="https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.js"></script>
    <script>
        const CONFIG = {
            GEOJSON_URL: 'data/2010_Block_Groups.geojson',
            NAMES_TXT_URL: 'data/requested_bg.txt',
            COLOR_FILL: '#34d399',
            COLOR_OUTLINE: '#065f46'
        };
        document.getElementById('gj-url').textContent = CONFIG.GEOJSON_URL;
        document.getElementById('csv-url').textContent = CONFIG.NAMES_TXT_URL;


        const map = new maplibregl.Map({
            container: 'map',
            center: [-84.582236, 42.697406],
            zoom: 12,
            style: 'static/map-style.json', //osm_liberty style json
        });
        map.addControl(new maplibregl.NavigationControl());

        let currentSourceKey = 'block-groups';

        map.on('load', async () => {
            await loadAndRender();
            document.getElementById('reload').addEventListener('click', loadAndRender);
        });

        //BG Load
        async function loadAndRender() {
            const status = setStatus('Loading files…');
            setLoading(true);
            try {
                //Pull both GeoJSON and Requested BGs
                const [gj, txt] = await Promise.all([
                fetch(CONFIG.GEOJSON_URL, { cache: 'no-store' }).then(r => r.json()),
                fetch(CONFIG.NAMES_TXT_URL, { cache: 'no-store' }).then(r => r.text())
                ]);

                //Check requested list
                const requestedNames = parseNamesTxt(txt);
                if (requestedNames.size === 0) {
                    setStatus('The requested BG list is empty. No overlay.');
                } else {
                    setStatus('Loaded $(requestedNames.size} BG(s) from list. Filtering...)');
                }

                const filtered = filterGeoJSONByCountyAndNames(gj, requestedNames, '065'); //pre-filter GeoJSON

                //Check if source already exists
                if (map.getSource(currentSourceKey)) {
                    map.getSource(currentSourceKey).setData(filtered);
                } else {
                    map.addSource(currentSourceKey, {type: 'geojson', data: filtered});
                    map.addLayer({
                        id: 'bg-fill',
                        type: 'fill',
                        source: currentSourceKey,
                        paint: {
                            'fill-color': CONFIG.COLOR_FILL,
                            'fill-opacity': 0.2
                        }
                    });
                    map.addLayer({
                        id: 'bg-outline',
                        type: 'line',
                        source: currentSourceKey,
                        paint: {
                            'line-color': CONFIG.COLOR_OUTLINE,
                            'line-width': 1
                        }
                    });
                    //TODO Pull and show data on click
                    //Show basic polygon info on click
                    map.on('mouseenter', 'bg-fill', () => { map.getCanvas().style.cursor = 'pointer'; });
                    map.on('mouseleave', 'bg-fill', () => { map.getCanvas().style.cursor = ''; });

                    map.on('click', 'bg-fill', (e) => {
                    if (!e.features?.length) return;

                    const feature = e.features[0];
                    const p = feature.properties || {};

                    new maplibregl.Popup({ closeButton: true, closeOnClick: true })
                        .setLngLat(e.lngLat)
                        .setHTML(`
                        <div style="font: 13px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;">
                            <div><b>NAME</b>: ${p.NAME ?? ''}</div>
                            ${p.LABEL ? `<div><b>LABEL</b>: ${p.LABEL}</div>` : ''}
                            ${p.TYPE ? `<div><b>TYPE</b>: ${p.TYPE}</div>` : ''}
                            ${p.CNTY_CODE ? `<div><b>CNTY_CODE</b>: ${p.CNTY_CODE}</div>` : ''}
                        </div>
                        `)
                        .addTo(map);
                    });

                }

                const hadFeatures = fitToGeoJSON(filtered);
                if (!hadFeatures) {
                    setStatus('No features matched the requested Block Group list.');
                } else {
                    setStatus(`Rendering ${filtered.features.length} matching polygon(s).`);
                }
            } catch (err) {
                console.error(err);
                setStatus('Error loading files.');
            } finally {
                setLoading(false);
            }
        }

        //Helper Functions
        function parseNamesTxt(text) {
            const names = new Set();
            const cleaned = (text ?? '').replace(/^\uFEFF/, '');
            for (const raw of cleaned.split(/\r?\n/)) {
                const line = (raw ?? '').trim();
                if (!line || line.startsWith('#')) continue;
                names.add(line);
            }
            return names;
        }


        function filterGeoJSONByCountyAndNames(geojson, requestedNames, countyCode = '065') {
            const feats = Array.isArray(geojson?.features) ? geojson.features : [];
            const features = feats.filter(f => {
                const p = f?.properties || {};
                return p.CNTY_CODE === countyCode && requestedNames.has(p.NAME);
            });
            return { type: 'FeatureCollection', features };
        }

        function fitToGeoJSON(geojson) {
            const bounds = new maplibregl.LngLatBounds();
            let count = 0;

            for (const f of geojson.features || []) {
                if (!f.geometry) continue;
                count++;
                walkGeom(f.geometry, (c) => bounds.extend(c));
            }
            if (count > 0 && !bounds.isEmpty()) {
                map.fitBounds(bounds, { padding: 40, duration: 700 });
                return true;
            }
            return false;
        }

        function walkGeom(geom, cb) {
            const t = geom.type, c = geom.coordinates;
            if (t === 'Point') cb(c);
            else if (t === 'MultiPoint' || t === 'LineString') c.forEach(cb);
            else if (t === 'MultiLineString' || t === 'Polygon') c.flat(1).forEach(cb);
            else if (t === 'MultiPolygon') c.flat(2).forEach(cb);
            else if (t === 'GeometryCollection') geom.geometries.forEach(g => walkGeom(g, cb));
        }

        function setStatus(message) {
            document.getElementById('status').textContent = message;
            return message;
        }

        function setLoading(isLoading) {
            const btn = document.getElementById('reload');
            btn.disabled = isLoading;
            btn.textContent = isLoading ? 'Loading…' : 'Reload list';
        }
    </script>
</body>
</html>